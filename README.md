## Golang 数据结构 & 算法

- [x] [位运算](bitwise.go)
  - 加减法 [☯](binary_operate.go)
  - 不用额外的变量交换两个变量 [☯](bitwise.go#L22)
  - 数组中仅有一个数是奇数个，其余数都是偶数个，找出奇数个的那个数 [☯](bitwise.go#L38)
  - 保留 int 型二进制数中最右侧的 1 [☯](bitwise.go#L51)
  - 数组中有两个数是奇数个，其余数都是偶数个，找出这两个数 [☯](bitwise.go#L69)
  - 二进制数中 1 的数量 [☯](bitwise.go#L109)
  
- [x] [链表](linked_list.go)
  - 单向链表 [☯](linked_list.go#L12)
    - 反转链表（迭代）
    - 把给定值都删除
  - 双向链表 [☯](linked_list.go#L77)
    - 实现头插、尾插、头出、尾出的双端链表
    - 反转双链表
  
- [x] [栈 & 队列](stack_queue.go)
  - 用双向链表实现栈 [☯](stack_queue.go#L17)
  - 用数组实现栈 [☯](stack_queue.go#L45)
  - 用双向链表实现队列 [☯](stack_queue.go#L80)
  - 用数组实现队列 [☯](stack_queue.go#L108)
  - 用两个栈实现队列 [☯](stack_queue.go#L175)
  - 用两个队列实现栈 [☯](stack_queue.go#L240)
  
- [x] 【树】
  - [前缀树](trie.go)
  
- [ ] [图]()
  
- [ ] [查找]()
  - 顺序查找
  - 折半查找
  
- [x] 【排序】
  - 比较排序
    - [选择排序](select_sort.go)
    - [冒泡排序](bubble_sort.go)
    - [插入排序](insert_sort.go)
    - [归并排序](merge_sort.go)
    - [快速排序](quick_sort.go)
    - [堆排序](heap_sort.go)（[堆结构](heap_structure.go)）
  - 桶排序（不基于比较的排序）
    - [计数排序](counting_sort.go)
    - [基数排序](radix_sort.go)
  - 排序算法总结

  |          | 时间复杂度 | 空间复杂度 | 稳定性 | 选用条件   |
  | -------- | ---------- | ---------- | ------ | ---------- |
  | 选择排序 | O(N^2)     | O(1)       | 不稳定 |            |
  | 冒泡排序 | O(N^2)     | O(1)       | 稳定   |            |
  | 插入排序 | O(N^2)     | O(1)       | 稳定   |            |
  | 归并排序 | O(N*log N) | O(N)       | 稳定   | 为了稳定性 |
  | 快速排序 | O(N*log N) | O(log N)   | 不稳定 | 为了速度   |
  | 堆排序   | O(N*log N) | O(1)       | 不稳定 | 为了空间   |
  | 计数排序 | O(N)       | O(M)       | 稳定   |            |
  | 基数排序 | O(N)       | O(N)       | 稳定   |            |

- [x] [递归](recursion.go)
  - 阶乘
  - 反转单链表
  
- [x] 分治
  - [归并排序](merge_sort.go) ★★★★☆
    - [计算数组的小和](small_sum.go)
    - [数组中的逆序对](reverse_pair.go)
    - 哪些场景可以利用归并排序的红利：
      两个组合并时，较小的那个数写入有序组前，可以立即算出另外一组中大于当前值的元素数量（end-cur+1）。
      即计算某个数的左组或右组中比它大的元素数量时，可以利用归并排序。

- [ ] [动态规划]()

- [ ] [贪心]()

- [ ] [回溯]()

- [ ] [分支限界法]()

